> 이 책을 읽는 이유: ‘모던 자바 인 액션’을 읽은 후, 자바 문법이 아니라 자바 자체를 더욱 잘 쓰고싶다는 생각을 하였고 이를 위해
> 

### CH02. 객체 생성과 파괴

- **생성자 대신 정적 패토리 메소드를 고려하라**
    - 장점
        - 이름을 가질 수 있음 → 객체 생성 시, 무엇을 위한 객체인지 설명이 가능해짐
        - 호출될 때마다 인스턴스를 새로 생성하지 않아도 됨 → 인스턴스를 통제하여 클래스의 사용을 원하는 방향으로 제어할 수 있음
        - 반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있음 → 유연성을 제공
        - 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있음
        - 정적 팩토리 메소드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 됨
            - 대체 무슨 말일까?
            - 하나의 예로 자바의 `Class.forName()` 메소드를 사용하여 객체를 가져오는 방법을 사용할 수 있음
            - 사용할 구현체들의 이름은 정해졌지만 존재하지는 않는 경우, 정적 팩토리 메소드에서 위 메소드에 구현체 이름만 넣어 코드를 작성함으로써 클래스 존재에 덜 의존적으로 만들어 줄 수 있음
    - 단점
        - 상속에 조건이 생김
            - 나는 정적 팩토리 메소드를 사용할 때, 생성자는 `private`으로 만들어줬었음
            - 하지만 생성자가 public인 경우에만 하위 클래스를 만들 수 있음 (상속시 생성자를 호출하기 때문)
        - API 설명에 명확히 드러나지 않기 때문에 찾기 어려움 → Naming Convention을 통해 해소함
    - Naming Convention
        - `from`: 매개변수를 ‘하나’ 받아서 인스턴스를 반환
        - `of`: 여러 매개변수를 받아 인스턴스를 반환
        - `valueOf`: 좀 더 자세하게 어떤 매개변수를 받을지 명시하고 그에 따른 인스턴스 반환
        - `instance` or `getInstance`: 정해진 인스턴스 반환
        - `create` or `newInstance`: 새로운 인스턴스를 생성해 반환
        - `getType`: `getInstance`와 동작은 같지만 호출하는 클래스가 아닌 다른 클래스를 반환할 때 사용
        - `newType`: `newInstance`와 동작은 같지만 호출하는 클래스가 아니니 다른 클래스를 반환할 때 사용
- **생성자에 매개변수가 많다면 빌더를 고려하라**
    - 정적 팩토리 메소드와 생성자의 단점 → 선택적 매개변수에 대응이 어려움
    - 예를 들어, 필요 없는 매개변수도 `0`이나 `null`로 넘겨줘야 했음
        
        → 매개변수가 많아질수록 복잡하고 순서 맞추기도 번거로움
        
    - 이를 해결하기 위해 매개변수가 없는 생성자를 통해 객체를 생성하고 필요한 필드를 setter를 통해 채워주는 방법을 사용함
        
        → 일관성 검증이 어려움
        
    - 결국 이러한 단점들을 보완하기 위해 빌더 패턴이 사용됨
        - 생성할 클래스 내부에 정적 멤버 클래스로 빌더 클래스를 생성 (`Builder`)
        - 해당 `Builder`의 생성자와 메소드를 통해 매개변수 전달
        - `Builder`의 모든 메소드는 자기 자신 (`Builder`) 를 반환하므로 연쇄적으로 메소드 호출 가능
        - 객체 생성 메소드 (`build`) 호출 시, `Builder`객체의 필드를 사용하여 원하는 클래스의 객체 생성하여 반환
- **private 생성자나 열거 타입으로 싱글톤임을 보증하라**
    - 싱글톤 객체를 만드는 방법은 총 3가지임
    - public 필드 사용
        
        ```java
        public class Elvis {
        	public static final Elvis INSTANCE = new Elvis();
        	private Elvis() {}
       		public void leaveTheBuilding() {}
        }
        ```
        
        - 해당 클래스가 싱글톤인 것이 API에 명백히 드러남 → 왜지?
            
            (그냥 필드에 바로 접근 가능해서 그런듯함)
            
        - 간결함
    - 정적 팩토리 방식
        
        ```java
        public class Elvis {
        	private static final Elvis INSTANCE = new Elvis();
        	private Elvis() {}
       		public static Elvis getInstance() { return INSTANCE; }
       		public void leaveTheBuilding() {}
        }
        ```
        
        - 싱글톤이 아니게 변경하기 수월함 (`getInstance` 메소드만 수정해주면 됨)
        - 제네릭 싱글톤 팩토리로 변경이 수월함
            - 예를 들어, 싱글톤 객체가 여러 Type에 의존적인 상황일 때 유연하게 적용 가능
        - 객체 반환 메소드 (`getInstance`)를 Supplier 함수로 사용 가능함
    - 원소가 하나인 Enum으로 선언
        
        ```java
        public enum Elvis {
        	INSTANCE;
        	public void leaveTheBuilding() {}
        }
        ```
        
        - 직렬화에 편함
        - 하지만 상속을 구현해야한다면 사용 못함
