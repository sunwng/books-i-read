> 이 책을 읽는 이유: 동료들과 더 좋은 코드 리뷰를 위해
> 

### CH01. 코드 품질

- 고품질의 코드는
    - 신뢰할 수 있고
    - 유지보수가 쉬우며
    - 요구 사항을 충족하는
    - 소프트웨어가 될 가능성을 최대한으로 높여줌
- 코드는 작동해야 한다
    - 당연한 코드의 첫 번째 목표
    - 원하는 목적대로 동작해야 함
- 코드는 작동이 멈추면 안 된다
    - 코드가 의존하는 다른 코드가 변경되더라도 작동하도록 해야 함
- 코드는 변경된 요구 사항에 적응할 수 있어야 한다
    - 변화하는 비지니스 환경과 사용자 선호에 따라 가정이 더이상 유효하지 않고 새로운 기능이 추가될 수 있음
    - 이에 쉽게 적응할 수 있어야 함
    - 하지만 너무 먼 미래를 고려하면 속도가 늦어지니 적당한 트레이드오프를 찾아야 함
- 코드는 이미 존재하는 기능을 중복 구현해서는 안 된다
    - 기존 코드를 재활용하면
        - 시간과 노력을 절약하고
        - 버그 가능성을 줄여주고
        - 기존 전문지식을 활용하며
        - 코드가 이해하기 쉬운
        - 효과를 얻을 수 있음
- 코드 품질의 핵심 요소 (6가지임)
    - 코드는 읽기 쉬워야 한다
    - 코드는 예측 가능해야 한다
    - 코드를 오용하기 어렵게 만들어라
    - 코드를 모듈화해라
    - 코드를 재사용 가능하고 일반화할 수 있게 작성하라
    - 테스트가 용이한 코드를 작성하고, 제대로 테스트해라

### CH02. 추상화 계층

- 문제를 해결하는 코드를 잘 구성하는 것은
    
    → 간결한 추상화 계층을 만드는 것으로 귀결될 때가 많음
    
- 왜 추상화 계층을 만들어야할까?
    - 이미 해결된 하위문제에 대해서 생각하지 않아도 되게 함
- 이를 위해서는 클래스도 잘 나눠야하고 함수도 잘 나눠야 함
    - 한 클래스가 300줄을 넘어간다는 것은 제대로 추상화되지 않았을 가능성이 높음
    - 클래스는 응집력이 높게 설계해야 함
        - 응집력은 순서에 의한 순차적 응집력과 기능에 의한 기능적 응집력이 있음
    - 예를 들어, 함수명이 너무 길어진다는 것은
        - 해당 함수가 두 가지 이상의 일을 하고 있거나
        - 해당 함수가 제대로 추상화되지 않았을
        - 가능성이 높음
- 하나의 하위 문제에 대해 (1) 둘 이상의 서로 다른 구체적인 구현이 가능하고 (2) 구현 클래스 사이에 전환이 필요하다면
    
    → 인터페이스를 사용하는 것이 좋음
    
    - 하지만 한 가지 구현만 존재하고 앞으로 다른 구현을 추가할 계획이 없다면 팀과 결정해야함
    - 이런 경우에는 인터페이스를 사용하는 것엔 장단점이 있으니 충분히 고민해보고 결정하자

### CH03. 다른 개발자와 코드 계약

- 다른 개발자들이 활발하게 코드를 변경하더라도 코드의 품질이 유지되려면 코드가 튼튼하고 사용하기 쉬워야 함
- 이를 위해 명심할 것
    - 자신에게 분명하다고 해서 다른 사람에게도 분명한 것은 아님
        
        → 이를 위해 주석을 많이 사용하는 것이 아닌, 코드 그 자체로 이해하기 쉽고 설명되게 해야함
        
    - 다른 개발자는 무의식중에 나의 코드를 망가뜨릴 수 있음
        
        → 내가 작성한 코드에 대해 테스트코드를 작성하고 이를 병합 전 체크하게 함으로써 망가지는 것을 방지해야함
        
    - 시간이 지나면 자신의 코드를 기억하지 못함
        
        → 위의 두 항목은 언제든지 나에게도 나의 코드에 대해 찾아올 수 있음
        
- 어떻게 내가 작성한 코드의 사용법을 다른 사람들이 알게할까?
    - 그들이 알아야할 내용
        - 여러 가지 상황에서 어떤 함수를 호출해야 하는지
        - 클래스가 무엇을 나타내고 언제 사용되어야 하는지
        - 어떤 값을 인수로 사용해야 하는지
        - 코드가 수행하는 동작이 무엇인지
        - 어떤 값을 반환하는지
    - 그리고 보통 이를 위해
        - 함수/클래스/열거형 등의 이름을 살펴보거나
        - 함수와 생성자의 매개변수 유형 or 반환값의 유형과 같은 데이터 유형을 살펴봄
    - 따라서 일단 뭐든지간에 “이름을 잘 지어야” 직관적으로 명확하게 전달할 수 있음
    - 또한, 코드가 오작동하지 않도록 데이터 유형을 잘 정해둬야함
    - 작성한 코드를 사용할 때 구체적인 제약 사항이 있다면 주석을 사용하는 것은 바람직하지 않을 수 있음
        
        → 코드 자체에 지켜진 순서를 따르지 않으면 적절한 에러를 발생시키거나 null을 반환하게 함으로써 해결해야함
        
        (예를 들어, 생성자를 호출하면 안되는 경우 아예 private으로 만들어버린다던지)
        
    - 이러한 해결 방법은 ‘상태’와 ‘가변성’을 최소화 or 외부로의 노출을 없앰

### CH04. 오류

- 복구 가능성
    - 복구 가능한 오류
        - 치명적이지 않은 경우, 오류가 발생하더라도 사용자가 알아채지 못하도록 적절히 처리하면 작동을 계속할 수 있음
        - 그 예로, 잘못된 사용자 입력 or 네트워크 오류 or 중요하지 않은 작업 오류 등이 있음
        - 시스템 외부의 무언가에 의해 야기되는 오류는 그에 대한 처리를 해주기 위해 노력해야 함
            
            → 예상할 수 있는 경우이기 때문
            
    - 복구할 수 없는 오류
        - 프로그래밍 오류일 떄가 많음 → 코드를 잘못 사용
        - 피해를 최소화하고 개발자가 문제를 발견하고 해결할 가능성을 최대화 하는 것이 방법
    - 그렇다면 어떻게 복구할 수 있을까?
        - 하드 코딩이 되어있다면 → 당연히 복구 불가능
        - 일반적으로 함수가 어떻게 사용되고 어디서 호출되는지 알 수 없음
            
            → 즉, 해당 함수를 호출하는 쪽에서 복구를 진행해야함
            
        - 그렇기에 아래의 경우에는 호출 함수의 오류는 호출하는 쪽에서 복구하고자 하는 것으로 간주해야 함
            - 함수가 어디서 호출될지 그리고 호출 시 제공되는 값이 어디서 올지 정확한 지식이 없을 때
            - 코드가 미래에 재사용될 가능성이 아주 희박할 때
- 어떻게 호출하는 쪽에서 오류를 알 수 있을까?
    
    = 어떻게 오류를 전달할 수 있을까?
    
    - 명시적 방법: 오류가 발생할 수 있음을 인지할 수 밖에 없도록 함
        - 검사 예외 (Checked Exception)
            - 예외 처리를 위한 코드를 작성하거나 함수 시그니처에 해당 예외 발생을 선언하도록 강제함
        - 널값이 가능한 반환 유형
            - 에러 발생 시 널이 반환될 수 있다는 것을 호출하는 쪽에서 강제적으로 인지하게 함
            (시그니처 or 객체 타입으로 확인)
            - 널 안정성을 지원하지 않는다면 옵셔널 반환 유형을 사용해야 함
        - 리절트 반환 유형
            - 널값 or 옵셔널 타입의 경우, 오류 정보를 전달할 수 없다는 단점이 있음
            - value와 error를 모두 포함하도록 리절트 객체 사용
            - 하지만 언어 자체에서 지원하지 않는다면 섬세하게 구현되어야함
                - 예를 들어, `getValue()` 호출 전에 무조건 `hasError()` 가 실행되어야함
        - 아웃컴 반환 유형
            - 반환값을 통해 오류 발생 여부를 알림 → 값을 강제적으로 확인해야 하므로 명시적임
            (결과를 나타내는 값임)
            - 하지만, 반환값을 무시하거나 값을 반환한다는 사실을 인식 못할 수 있음 → 한계가 있음
            - 자바의 경우 `@CheckReturnValue` 어노테이션을 통해 반환값을 무시하면 컴파일러가 경고하도록 할 수 있음
    - 암시적 방법: 오류가 발생할 수 있음을 알리지만, 신경쓰지 않아도 됨
        - 비검사 예외 (Unchecked Exception)
            - 이 경우에는 예외가 발생할 수 있다는 사실을 모를 수 있음
        - 프로미스 or 퓨처
            - 호출하는 쪽에서는 잠재적인 오류의 시나리오를 완벽하게 알지 못함 → `then()` 함수만 사용할 수 있음
        - 매직값 반환
            - 개발자가 정한 특정 값에 의미를 부여하여 알림
- 견고성 vs 실패
    - 오류 발생 시 선택할 수 있는 방법
        - 실패 (더 높은 계층이 오류를 처리하거나 전체 프로그램의 작동을 멈춤)
        - 견고성 (오류를 처리하고 계속 진행)
    - 대부분의 경우 실패가 최선임
    - “신속하게 실패하라”
        
        = 가능한 한 문제의 실제 발생 지점으로부터 가까운 곳에서 오류를 나타내야 함
        
        → 복구할 수 있는 경우, 호출하는 쪽에서 오류로부터 안전하게 복구할 수 있는 기회를 최대한 제공함
        
        → 복구할 수 없는 경우, 개발자가 문제를 신속하게 파악하고 해결할 수 있는 기회를 최대한 제공함
        
    - “요란하게 실패하라”
        
        = 오류가 발생하는데도 불구하고 아무도 모르는 상황을 막고자 함
        
        - 예외를 발생시켜 프로그램이 중단되게 해야 함
    - 여기서 모순점이 존재함
        - 가장 요란하게 실패하는 것은 프로그램을 멈추는 것인데, 이것은 프로그램을 견고하지 못하게 만듦
        
        ⇒ `try-catch` 등을 활용하여 오류가 발생해도 프로그램을 진행시킬 수 있게 하고 오류를 기록 & 모니터링해야함
        
    - 오류를 숨기지 말아야 함
        - 때로는 오류를 숨기고 아무 일도 없었던 것처럼 동작하도록 코드를 작성하고 싶을 수 있음
        - 하지만 이것은 소프트웨어가 의도한대로 작동하지 않게 만듦
        - 오류를 숨기는 안티 패턴
            - 기본값 반환 → 기본값이 의미가 있을 수 있기에 이렇게 하지 말고 오류를 던져야함
            - 널 객체 패턴 → 유용할 수 있지만 종종 버그로 이어지기 쉬움
            - 아무것도 하지 않음 (e.g. `return;`) → 호출하는 쪽에서는 정상 처리가 된것으로 생각하므로 바람직하지 않음
            
    ⇒ 복구 가능성이 없는 오류가 발생하면 “신속”하고 “요란”하게 실패하는 것이 최상의 방법

- 비검사 예외를 사용해야한다 vs 명시적 기법을 사용해야한다
    - 오류 핸들링에는 아직 정도가 없기에 두 의견이 분분함
    - “비검사 예외를 사용해야한다”의 장점
        - 코드 구조 개선
            - 대부분의 오류 처리가 코드의 상위 계층에서 이뤄질 수 있기 때문에 코드의 구조를 개선할 수 있음
        - 개발자들이 무엇을 할 것인지에 대해서 실용적이어야 함
            - 검사 예외를 사용하게 되면, 시그니처에 표시해야함
            - 하지만 이 경우, 해당 함수를 호출하는 모든 코드를 수정해야함
            - 이게 귀찮다고 여겨 오류를 숨기고 `try-catch`만으로 처리시킬 수 있음
            - 이러한 사고와 과정이 실용적이지 못하다는 주장
    - “명시적 기법을 사용해야 한다”의 장점
        - 매끄러운 오류 처리
            - 비검사 예외를 사용하면 오류를 매끄럽게 처리할 수 있는 단일 계층을 갖기 어려움
            - 호출하는 쪽에 잠재적 오류를 강제적으로 인식하도록 하면 이러한 오류를 좀 더 매끄럽게 처리할 가능성이 커짐
        - 실수로 오류를 무시할 수 없음
        - 개발자들이 무엇을 할 것인지에 대해서 실용적이어야 함
            - 비검사 예외를 사용하면 제대로 문서화된다는 보장이 없음