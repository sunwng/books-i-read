### CH9. 리팩터링, 테스팅, 디버깅

- 람다 표현식을 사용하면 코드 가독성이 좋아짐
- 하지만 항상 좋은 것은 아님
    - 람다가 굉장히 복잡해질 때가 있는데, 그건 그냥 메소드로 따로 만들어주고 메소드 참조를 해주면 굿
- for loop 도 stream 으로 처리해주면 가독성이 좋아짐 (파이프라인의 의도가 보임)
- 메소드의 파라미터를 함수형 인터페이스(Consumer, Predicate, Function, …)로 선언해주고 사용 시에 람다로 넣어주는 것도 방법
- 팩토리 메소드 역시 Supplier를 통해 처리해줄 수 있음 (Map에 각각에 맞는 Supplier 추가)
- 복잡한 람다는 당연하게도 유닛 테스팅이 어려움
- 디버깅 시, 람다에서는 스택 트레이스가 보기 어려움

### CH11. null 대신 Optional 클래스

- NullPointerException 은 많은 사람들을 괴롭히는 만큼 피할 수 있다면 최대한 피해야함
- null check 하는 if문들 덕분에 코드의 구조는 엉망이 되고있었음
- 이를 해결하기 위해 Optional 클래스가 도입되었음
- `Optional.empty()` 로 비어있는 Optional 객체 생성
- `Optional.of()` 로 객체를 포함하는 Optional 객체 생성
- `Optional.ofNullable()` 로 객체를 넣으면 null 인지 확인하고 알아서 해줌
- empty 인지 확인은 `.isPresent()`
- empty 아닐 때의 행동을 정의하려면 `.ifPresent()` → consumer 넣어줘야함
- `.ifPresentOrElse()` 를 쓰면 있을 때 없을 때 둘 다 가능
- `.get()` 으로 안에 있는 객체를 가져옴 (empty 아닐때 가능)
- `.orElse()` 를 쓰면 empty 일때의 행동을 정의할 수 있음
- `.orElseGet()` 과의 차이점은 `.orElse()` 는 Supplier가 항상 실행되고 없으면 적용되지만 `.orElseGet()` 은 실행되지 않고 없으면 실행 후 적용됨
- empty 일 때 예외를 발생시키고 싶으면 `orElseThrow()`
- Optional 객체에 `.filter()` 연산을 적용하면 깔끔함 (stream 처리 가능)
- Optional 객체를 try catch 에 사용하여 항상 exception 이 발생할 수 있는 곳에 처리해주면 좋음

### CH12. 새로운 날짜와 시간 API

- 기존의 자바는 `java.util.Date` 클래스 하나만 존재했음
- 이후에는 DateFormat 을 제공했는데 이건 스레드에 안전하지 않았음
- 이젠 `java.time` 패키지를 사용하자
- 자주 봐왔던 `LocalDate`, `LocalTime`, `LocalDateTime` 이 이 패키지에 있음
- LocalDate 는 팩토리 메소드인 `.of()` 에 year, month, day 를 넣어서 생성
- 또는 `.now()` 로 현재 날짜 생성
- 이후에는 `getYear()`, `getMonth()` 등의 메소드 사용
- LocalTime 은 팩토리 메소드인 `.of()` 에 hour, minute, second 를 넣어서 생성
- 두개를 합친게 LocalDateTime → 이걸 쓰자