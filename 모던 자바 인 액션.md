### CH9. 리팩터링, 테스팅, 디버깅

- 람다 표현식을 사용하면 코드 가독성이 좋아짐
- 하지만 항상 좋은 것은 아님
    - 람다가 굉장히 복잡해질 때가 있는데, 그건 그냥 메소드로 따로 만들어주고 메소드 참조를 해주면 굿
- for loop 도 stream 으로 처리해주면 가독성이 좋아짐 (파이프라인의 의도가 보임)
- 메소드의 파라미터를 함수형 인터페이스(Consumer, Predicate, Function, …)로 선언해주고 사용 시에 람다로 넣어주는 것도 방법
- 팩토리 메소드 역시 Supplier를 통해 처리해줄 수 있음 (Map에 각각에 맞는 Supplier 추가)
- 복잡한 람다는 당연하게도 유닛 테스팅이 어려움
- 디버깅 시, 람다에서는 스택 트레이스가 보기 어려움

### CH11. null 대신 Optional 클래스

- NullPointerException 은 많은 사람들을 괴롭히는 만큼 피할 수 있다면 최대한 피해야함
- null check 하는 if문들 덕분에 코드의 구조는 엉망이 되고있었음
- 이를 해결하기 위해 Optional 클래스가 도입되었음
- `Optional.empty()` 로 비어있는 Optional 객체 생성
- `Optional.of()` 로 객체를 포함하는 Optional 객체 생성
- `Optional.ofNullable()` 로 객체를 넣으면 null 인지 확인하고 알아서 해줌
- empty 인지 확인은 `.isPresent()`
- empty 아닐 때의 행동을 정의하려면 `.ifPresent()` → consumer 넣어줘야함
- `.ifPresentOrElse()` 를 쓰면 있을 때 없을 때 둘 다 가능
- `.get()` 으로 안에 있는 객체를 가져옴 (empty 아닐때 가능)
- `.orElse()` 를 쓰면 empty 일때의 행동을 정의할 수 있음
- `.orElseGet()` 과의 차이점은 `.orElse()` 는 Supplier가 항상 실행되고 없으면 적용되지만 `.orElseGet()` 은 실행되지 않고 없으면 실행 후 적용됨
- empty 일 때 예외를 발생시키고 싶으면 `orElseThrow()`
- Optional 객체에 `.filter()` 연산을 적용하면 깔끔함 (stream 처리 가능)
- Optional 객체를 try catch 에 사용하여 항상 exception 이 발생할 수 있는 곳에 처리해주면 좋음

### CH12. 새로운 날짜와 시간 API

- 기존의 자바는 `java.util.Date` 클래스 하나만 존재했음
- 이후에는 DateFormat 을 제공했는데 이건 스레드에 안전하지 않았음
- 이젠 `java.time` 패키지를 사용하자
- 자주 봐왔던 `LocalDate`, `LocalTime`, `LocalDateTime` 이 이 패키지에 있음
- LocalDate 는 팩토리 메소드인 `.of()` 에 year, month, day 를 넣어서 생성
- 또는 `.now()` 로 현재 날짜 생성
- 이후에는 `getYear()`, `getMonth()` 등의 메소드 사용
- LocalTime 은 팩토리 메소드인 `.of()` 에 hour, minute, second 를 넣어서 생성
- 두개를 합친게 LocalDateTime → 이걸 쓰자

### CH13. 디폴트 메서드

- 기존의 자바에서는 인터페이스에 메소드를 추가하는 등의 수정이 발생하면 모든 구현 클래스에 문제가 발생했음
- 이를 해결하는 두가지 방법은 1. 정적 메소드 사용 2. 디폴트 메소드 사용 임
- 디폴트 메소드를 사용하면 구현 클래스가 그대로 상속함 → 새로 추가되는 메소드를 구현할 필요 없음
- 디폴트 메소드는 인터페이스의 메소드 제일 앞에 `default` 키워드를 사용
- 하지만 이로 인해서 default 메소드의 다중 상속 문제가 생길 수 있음
(interface 는 여러개를 구현 가능한데, 같은 이름의 default 메소드가 존재할 수 있음)
- 이를 위한 규칙이 존재함
    - 일단 클래스나 슈퍼클래스를 상속 받게될 때 이름이 같은 디폴트 메소드보다 우선권을 가짐
    - 그 다음은 서브인터페이스가 우선권을 가짐
    (디폴트 메소드를 가진 인터페이스 A 를 상속받고 디폴트 메소드를 재정의한 인터페이스 B 가 있을 때 B가 우선권)
    - 그래도 우선순위가 정해지지 않으면 오버라이드해야함 → `target.super.method()` 의 형태

### CH14. 자바 모듈 시스템

- 자바9부터는 관심사분리를 통해 모듈화
- 흠, 근데 왜이미 접근 제한자와 패키지가 있는데 또다른 그룹화가 필요한지 의문
- 음 일단 패키지에 대해서는 캡슐화를 지원하지 않았음
- `module-info.java` 에 module descriptor 를 저장함
- module descriptor 는 module 모듈명 / exports 패키지명 / requires 모듈명 의 구조를 가짐
- Maven or Gradle 을 사용하면 이런건 IDE가 처리함
- module 은 보통 project 단위임