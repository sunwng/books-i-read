> 이 책을 읽는 이유: 
> 
> Java / Kotlin 은 객체지향 언어이며 Spring 은 객체지향 프레임워크다
> 
> 나는 과연 객체지향을 잘 알고 사용하고 있을까?
> 
> 어떻게 해야 객체지향적인 시스템을 만들 수 있을까?
> 

## CH01. 협력하는 객체들의 공동체

- 객체지향의 목표는 실세계를 모방하는 것이 아님 (흔히 설명하는 객체지향)
- 협력하는 사람들
    - 그럼에도 불구하고, 실세계를 모방하는 것은 객체들이 돌아가는 원리를 잘 표현해주기 때문에 한번 살펴보자
    - 커피를 만들 때조차도 역할, 책임, 협력 이라는 세 가지 개념이 조화를 이뤄져야 함
    - 협력 → 요청과 응답을 통해 이뤄짐
    - 역할 & 책임
        - 여러 사람이 동일한 역할을 수행할 수 있음 (점원이 누구든, 바리스타가 누구든, 원하는 응답만 받으면 됨)
        - 역할은 대체 가능성을 의미함
        - 책임을 수행하는 방법은 자율적으로 선택할 수 있음 (바리스타는 커피를 어떤식으로든 만들 수 있음)
        - 한 사람이 동시에 여러 역할을 수행할 수 있음 (점원이 바리스타 역할도 수행할 수 있음)
- 역할, 책임, 협력
    - 객체지향 설계는 적절한 객체에게 적절한 책임을 할당하는 것에서 시작됨
    - 여러 객체가 동일한 역할을 수행할 수 있음
    - 역할은 대체 가능성을 의미함
    - 각 객체는 책임을 수행하는 방법을 자율적으로 선택할 수 있음
    - 하나의 객체가 동시에 여러 역할을 수행할 수 있음
- 협력 속에 사는 객체
    - 객체는 어플리케이션의 기능을 구현하기 위해 존재함
    - 객체는 충분히 ‘협력적’이어야 함
        - 모든 것을 스스로 처리하려는 전지전능한 객체는 내부 복잡도에 의해 자멸하게 됨
    - 객체는 충분히 ‘자율적’이어야 함
        - 요청에 따른 응답을 자율적으로 판단하고 결정해야 함
    - 이를 위해서 객체는 필요한 행동과 상태를 함께 지니고 있어야 함
- 객체지향의 본질
    - 시스템을 상호작용하는 자율적인 객체들의 공동체로 바라보고, 객체를 이용해 시스템을 분할하는 방법
    - 자율적인 객체란 상태와 행위를 지니고 자기 자신을 책임지는 객체를 의미함
    - 객체는 시스템의 행위를 구현하기 위해 다른 객체와 협력함 (역할 / 책임)
    - 객체는 다른 객체와 협력하기 위해 메시지를 전송하고, 메시지를 수신한 객체는 적절한 메소드를 자율적으로 선택하여 메시지를 처리함
- 코드를 담는 클래스의 관점에서 메시지를 주고받는 객체의 관점으로 사고의 중심을 전환하자!!

## CH02. 이상한 나라의 객체

- **객체**
    - 상태
    - 행동
    
    → 상태와 행동을 지니는 객체들 간의 협력 (상호작용) → 소프트웨어
    
- **상태**
    - 행동을 하기 위해선 상태가 필요하다 (precondition)
    - 그리고 현재의 상태는 과거의 모든 행동의 결과물 = 현재의 상태를 기반으로 과거의 행동을 예측할 수 있음
    - 구성
    - Property (정적)
    - Primitive
    - Reference (Link)
    - Property value (동적)
- **행동**
    - 객체의 상태를 변화시키기 위한 유일한 방법
    - 객체는 직접 행동하여 자신의 상태를 변경해야함 (다른 객체에게 요청을 해야한다 = 메시지를 보내야한다)
    - 옳지 못한 방법
        
        ```jsx
        class Alice() {
            fun drink(beverage: Beverage, amount: Int) {
        	beverage.amount -= amount
            }
        }
        ```
        
    - 옳은 방법
        
        ```jsx
        class Alice() {
            fun drink(beverage: Beverage, amount: Int) {
        	beverage.decrease(amount)
            }
        }
        ```
    
    = 캡슐화 (객체가 외부에 노출하는 것은 행동뿐이다)
    
    - 객체의 상태를 파악하는 행동 = 쿼리
    - 객체의 상태를 변화시키는 행동 = 커맨드

❓❓ 객체의 상태를 확인하고 상태를 변화시키는 행동은 꼭 분리되어서 존재해야할까? ❓❓

```
if (sample.getStatus) sample.doSomething()

---

sample.doSomething()

class Sample() {
...
    fun doSomething() {
	if (getStatus == false) return;
	...
    }
}
```

- **식별자**
    - 객체를 서로 구별할 수 있게 함
- **행동이 상태를 결정한다**
    - 객체의 상태를 먼저 결정하고 행동을 따라서 결정하는 방법 = **“안티패턴”**
    - 깔끔한 캡슐화를 방해함 (공용 인터페이스에 상태가 노출될 확률이 높아짐)
    - 객체의 협력을 어렵게 함
    - 재사용성이 저하됨
    
    → 객체의 설계는 객체의 행동부터 생각해야 함
    
    - 객체의 행동 = 객체의 책임 ⇒ 협력할 때 어떤 책임이 필요한가를 먼저 결정하자
- **오해**
    - (1장) 객체지향 ≠ 클래스 → 객체지향 = 상태 + 행동
    - 객체지향은 현실세계의 모방이 아니다
    - 현실에서는 대부분의 객체가 수동적이지만
    - 소프트웨어에서의 객체는 모두가 능동적이다

## CH03. 타입과 추상화

- 추상화
    - 어떤 양상, 세부 사항, 구조를 좀 더 명확하게 이해하기 위해 특정 절차나 물체를 의도적으로 생략하거나 감춤으로써 복잡도를 극복하는 방법
    - 어떻게?
        1. 구체적인 사물들 간의 공통점은 취하고 차이점을 버리는 일반화를 통해 단순하게 만들자
        2. 중요한 부분을 강조하기 위해 불필요한 세부 사항을 제거함으로써 단순하게 만들자
    
    ⇒ 추상화의 목적은 “복잡성을 이해하기 쉬운 수준으로 단순화 하는것”이다!
    
- 타입
    - 공통점을 기반으로 객체들을 묶기 위한 틀
    - 데이터 타입
        - 데이터 타입은 데이터가 어떻게 사용되느냐에 관한 것임
            
            (어떤 연산자를 적용할 수 있는가)
            
        - 메모리에 어떻게 표현되는지는 외부로부터 철저히 감춰짐
    - 전통적인 데이터 타입과 객체에서의 타입은 다르지만 깊은 연관성이 있음
        - 결국, 타입을 정의하고 이름을 붙인다는 것은 프로그램에서 사용할 새로운 데이터 타입을 선언하는 것이기 때문
        - 하지만, 객체는 데이터가 아니다
    - 그러면 어떻게 객체의 타입을 설계해야할까?
        - 어떤 객체가 어떤 타입에 속하는지를 결정하는 것은 객체가 수행하는 행동임
        - 객체의 내부적인 표현은 외부로부터 철저하게 감춰짐
        
        ⇒ 객체의 내부 표현 방식이 다르더라도 어떤 객체들이 동일하게 행동한다면, 그 객체들은 동일한 타입이다!
        
    - 행동이 같으면 같은 타입의 객체라는 것 = 다형성
    - 내부 표현 방식을 철저하게 감추고 행동을 제공한다는 것 = 캡슐화
- 타입의 계층
    - 한 타입은 다른 타입을 확장할 수 있음
    - 즉, 두 타입은 일반화/특수화 관계를 가질 수 있음
        - 일반적인 타입 → Supertype
        - 특수한 타입 → Subtype
    - 그리고 이 관계를 결정하는 것은 객체의 상태가 아닌 객체의 행동임
