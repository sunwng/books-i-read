> 이 책을 읽는 이유: 
> 
> Java / Kotlin 은 객체지향 언어이며 Spring 은 객체지향 프레임워크다
> 
> 나는 과연 객체지향을 잘 알고 사용하고 있을까?
> 
> 어떻게 해야 객체지향적인 시스템을 만들 수 있을까?
> 

## CH01. 협력하는 객체들의 공동체

- 객체지향의 목표는 실세계를 모방하는 것이 아님 (흔히 설명하는 객체지향)
- 협력하는 사람들
    - 그럼에도 불구하고, 실세계를 모방하는 것은 객체들이 돌아가는 원리를 잘 표현해주기 때문에 한번 살펴보자
    - 커피를 만들 때조차도 역할, 책임, 협력 이라는 세 가지 개념이 조화를 이뤄져야 함
    - 협력 → 요청과 응답을 통해 이뤄짐
    - 역할 & 책임
        - 여러 사람이 동일한 역할을 수행할 수 있음 (점원이 누구든, 바리스타가 누구든, 원하는 응답만 받으면 됨)
        - 역할은 대체 가능성을 의미함
        - 책임을 수행하는 방법은 자율적으로 선택할 수 있음 (바리스타는 커피를 어떤식으로든 만들 수 있음)
        - 한 사람이 동시에 여러 역할을 수행할 수 있음 (점원이 바리스타 역할도 수행할 수 있음)
- 역할, 책임, 협력
    - 객체지향 설계는 적절한 객체에게 적절한 책임을 할당하는 것에서 시작됨
    - 여러 객체가 동일한 역할을 수행할 수 있음
    - 역할은 대체 가능성을 의미함
    - 각 객체는 책임을 수행하는 방법을 자율적으로 선택할 수 있음
    - 하나의 객체가 동시에 여러 역할을 수행할 수 있음
- 협력 속에 사는 객체
    - 객체는 어플리케이션의 기능을 구현하기 위해 존재함
    - 객체는 충분히 ‘협력적’이어야 함
        - 모든 것을 스스로 처리하려는 전지전능한 객체는 내부 복잡도에 의해 자멸하게 됨
    - 객체는 충분히 ‘자율적’이어야 함
        - 요청에 따른 응답을 자율적으로 판단하고 결정해야 함
    - 이를 위해서 객체는 필요한 행동과 상태를 함께 지니고 있어야 함
- 객체지향의 본질
    - 시스템을 상호작용하는 자율적인 객체들의 공동체로 바라보고, 객체를 이용해 시스템을 분할하는 방법
    - 자율적인 객체란 상태와 행위를 지니고 자기 자신을 책임지는 객체를 의미함
    - 객체는 시스템의 행위를 구현하기 위해 다른 객체와 협력함 (역할 / 책임)
    - 객체는 다른 객체와 협력하기 위해 메시지를 전송하고, 메시지를 수신한 객체는 적절한 메소드를 자율적으로 선택하여 메시지를 처리함
- 코드를 담는 클래스의 관점에서 메시지를 주고받는 객체의 관점으로 사고의 중심을 전환하자!!

## CH02. 이상한 나라의 객체

- **객체**
    - 상태
    - 행동
    
    → 상태와 행동을 지니는 객체들 간의 협력 (상호작용) → 소프트웨어
    
- **상태**
    - 행동을 하기 위해선 상태가 필요하다 (precondition)
    - 그리고 현재의 상태는 과거의 모든 행동의 결과물 = 현재의 상태를 기반으로 과거의 행동을 예측할 수 있음
    - 구성
    - Property (정적)
    - Primitive
    - Reference (Link)
    - Property value (동적)
- **행동**
    - 객체의 상태를 변화시키기 위한 유일한 방법
    - 객체는 직접 행동하여 자신의 상태를 변경해야함 (다른 객체에게 요청을 해야한다 = 메시지를 보내야한다)
    - 옳지 못한 방법
        
        ```jsx
        class Alice() {
            fun drink(beverage: Beverage, amount: Int) {
        	beverage.amount -= amount
            }
        }
        ```
        
    - 옳은 방법
        
        ```jsx
        class Alice() {
            fun drink(beverage: Beverage, amount: Int) {
        	beverage.decrease(amount)
            }
        }
        ```
    
    = 캡슐화 (객체가 외부에 노출하는 것은 행동뿐이다)
    
    - 객체의 상태를 파악하는 행동 = 쿼리
    - 객체의 상태를 변화시키는 행동 = 커맨드

❓❓ 객체의 상태를 확인하고 상태를 변화시키는 행동은 꼭 분리되어서 존재해야할까? ❓❓

```
if (sample.getStatus) sample.doSomething()

---

sample.doSomething()

class Sample() {
...
    fun doSomething() {
	if (getStatus == false) return;
	...
    }
}
```

- **식별자**
    - 객체를 서로 구별할 수 있게 함
- **행동이 상태를 결정한다**
    - 객체의 상태를 먼저 결정하고 행동을 따라서 결정하는 방법 = **“안티패턴”**
    - 깔끔한 캡슐화를 방해함 (공용 인터페이스에 상태가 노출될 확률이 높아짐)
    - 객체의 협력을 어렵게 함
    - 재사용성이 저하됨
    
    → 객체의 설계는 객체의 행동부터 생각해야 함
    
    - 객체의 행동 = 객체의 책임 ⇒ 협력할 때 어떤 책임이 필요한가를 먼저 결정하자
- **오해**
    - (1장) 객체지향 ≠ 클래스 → 객체지향 = 상태 + 행동
    - 객체지향은 현실세계의 모방이 아니다
    - 현실에서는 대부분의 객체가 수동적이지만
    - 소프트웨어에서의 객체는 모두가 능동적이다

## CH03. 타입과 추상화

- 추상화
    - 어떤 양상, 세부 사항, 구조를 좀 더 명확하게 이해하기 위해 특정 절차나 물체를 의도적으로 생략하거나 감춤으로써 복잡도를 극복하는 방법
    - 어떻게?
        1. 구체적인 사물들 간의 공통점은 취하고 차이점을 버리는 일반화를 통해 단순하게 만들자
        2. 중요한 부분을 강조하기 위해 불필요한 세부 사항을 제거함으로써 단순하게 만들자
    
    ⇒ 추상화의 목적은 “복잡성을 이해하기 쉬운 수준으로 단순화 하는것”이다!
    
- 타입
    - 공통점을 기반으로 객체들을 묶기 위한 틀
    - 데이터 타입
        - 데이터 타입은 데이터가 어떻게 사용되느냐에 관한 것임
            
            (어떤 연산자를 적용할 수 있는가)
            
        - 메모리에 어떻게 표현되는지는 외부로부터 철저히 감춰짐
    - 전통적인 데이터 타입과 객체에서의 타입은 다르지만 깊은 연관성이 있음
        - 결국, 타입을 정의하고 이름을 붙인다는 것은 프로그램에서 사용할 새로운 데이터 타입을 선언하는 것이기 때문
        - 하지만, 객체는 데이터가 아니다
    - 그러면 어떻게 객체의 타입을 설계해야할까?
        - 어떤 객체가 어떤 타입에 속하는지를 결정하는 것은 객체가 수행하는 행동임
        - 객체의 내부적인 표현은 외부로부터 철저하게 감춰짐
        
        ⇒ 객체의 내부 표현 방식이 다르더라도 어떤 객체들이 동일하게 행동한다면, 그 객체들은 동일한 타입이다!
        
    - 행동이 같으면 같은 타입의 객체라는 것 = 다형성
    - 내부 표현 방식을 철저하게 감추고 행동을 제공한다는 것 = 캡슐화
- 타입의 계층
    - 한 타입은 다른 타입을 확장할 수 있음
    - 즉, 두 타입은 일반화/특수화 관계를 가질 수 있음
        - 일반적인 타입 → Supertype
        - 특수한 타입 → Subtype
    - 그리고 이 관계를 결정하는 것은 객체의 상태가 아닌 객체의 행동임

## CH04. 역할, 책임, 협력

- 협력이라는 문맥이 객체의 행동 방식을 결정함
    - 문맥을 고려하지 않은 채, 상태와 행동부터 고민하기 시작하는 것 → 흔한 실수
- 또한, 객체지향 설계의 품질은 개별 객체의 품질이 만드는 것이 아니라 협력의 품질이 만드는 것
- 요청과 응답은 협력에 참여하는 객체가 수행할 책임을 정의함
- 책임
    - “객체지향 개발에서 가장 중요한 능력은 책임을 능숙하게 소프트웨어 객체에게 할당하는 것”
    - 분류
        - 하는 것
            - 객체를 생성 or 계산
            - 다른 객체의 행동을 시작시킴
            - 다른 객체의 활동을 제어하고 조절함
        - 아는 것
            - 개인적인 정보에 관해 아는 것
            - 관련된 객체에 관해 아는 것
            - 자신이 유도하거나 계산할 수 있는 것에 관해 아는 것
- 역할
    - 협력 내에서 다른 객체로 대채할 수 있음을 나타내는 표식
    - 유사한 협력을 하나의 협력으로 묶을 수 있게 함
    - 즉, 역할의 대체 가능성은 행위 호환성을 의미하고, 행위 호환성은 동일한 책임의 수행을 의미함

## CH05. 책임과 메시지

- 자율적인 책임
    - 자율적인 객체: 스스로의 의지와 판단에 따라 맡은 책임을 수행하는 객체
    - 책임은 메시지를 통해 전달됨
    - 그리고 그 메시지를 어떻게 처리할지에 대한 자율성은 행동하는 객체가 지님
    - 메시지가 너무 구체적이면 자율성을 제한하게 됨
    
    → 자율적인 객체를 위해서는 객체에게 할당되는 책임의 수준 역시 자율적이어야 함
    
    - 하지만, 너무 포괄적이고 추상적인 책임을 선택한다고 해서 무조건 좋은 것은 아님 (어쩌란거지)
    
    ⇒ 결론적으로, 책임이 수행 방법을 제한할 정도로 구체적이면 안되고 협력의 의도를 명확하게 표현하지 못할 정도로 추상적이어도 안됨
    
    - ‘어떻게’ 행동해야 하는가 가 아니라 ‘무엇’을 해야하는가 에 집중하자
- 메시지와 메소드
    - 한 객체가 다른 객체에게 접근하기 위한 유일한 방법은 메시지를 전송하는 것
    - 메소드는 메시지를 수행하는 방법
        - 이를 위해 객체 내부의 함수를 사용함
    - 같은 메시지에 대해 다른 메소드를 사용함으로써 다형성을 활용할 수 있음
- 객체 인터페이스
    - 인터페이스의 사용법만 익히면 내부 구조나 동작 방식을 몰라도 됨
    - 인터페이스의 내부 작동을 변경하는 것은 사용자에게 영향을 미치지 않음
    - 대상이 변경되더라도 동일한 인터페이스만 제공해주면 됨
    - 인터페이스는 객체끼리 협력하기 위한 접점임
- 인터페이스와 구현의 분리
    - 좀 더 추상적인 인터페이스
    - 최소 인터페이스 → 노출될 필요가 없는 인터페이스는 노출하지 말아야 함
    - 인터페이스와 구현 간에 차이가 있다는 점을 인식
    - 내부 구현을 인터페이스와 분리함으로써 캡슐화를 이룰 수 있음

## CH06. 객체 지도

- 전통적인 소프트웨어 개발 방법 → 기능에 구조를 종속시킴
    - but 빈번한 기능 변경은 재사용을 불가하게 함
- 객체지향 개발 방법 → 안정적인 구조에 기능을 종속시킴
- 구조
    - 사용자나 이해관계자들이 도메인에 관해 생각하는 개념과 개념들간의 관계
    - 도메인 모델 → 대상 영역에 관한 지식을 선택적으로 단순화하고 의식적으로 구조화한 형태
- 기능
    - 사용자의 목표를 만족시키기 위해 책임을 수행하는 시스템의 행위
    - 유스케이스 → 시스템의 이해관계자들 간의 계약을 행위 중심으로 파악한 것
    - 유스케이스를 통해 협력의 출발점인 시스템의 책임을 정의할 수 있음

## CH07. 함께 모으기

- 코드의 세 가지 관점
    - 개념 관점 → 도메인을 구성하는 개념과 관계를 반영
    - 명세 관점 → 클래스의 인터페이스를 고려 (메시지)
    - 구현 관점 → 클래스의 내부 구현