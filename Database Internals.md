> 이 책을 읽는 이유: 
> 
> 백엔드 개발자는 결국 데이터베이스에 데이터를 생성하고 가져오고 가공한다. 
> 
> 데이터베이스가 어떻게 작동하는지를 알면 더 효율적인 로직을 짤 수 있지 않을까?
> 

## 1부. 스토리지 엔진

스토리지 엔진은

- DBMS에서 데이터를 메모리와 디스크에 저장하고
- 검색 및 관리하며
- 각 노드에 데이터를 영구 저장함
- 그리고 복잡한 쿼리를 수행할 수 있도록 데이터를 세밀하게 조작할 수 있는 간단한 API를 제공함

### CH01. 소개 및 개요

- DBMS 구조
    - 표준화된 구조는 존재하지는 않음
    - 일반적으로는
        - `클라이언트의 요청`은 `트랜스포트 서브시스템`을 통해 전달됨
            
            (요청은 쿼리 형태)
            
        - `트랜스포트 서브시스템`은 쿼리를 `쿼리 프로세서`에게 전달함
            - `쿼리 프로세서`는 쿼리를 해석 / 분석 / 검증 함
            - 분석된 쿼리는 `쿼리 옵티마이저`에게 전달됨
            - `쿼리 옵티마이저`는 가장 효율적인 쿼리 실행 계획을 생성함
        - (로컬인 경우), `스토리지 엔진`이 쿼리를 수행함
            - 스토리지 엔진은
                - 트랜잭션을 스케줄링하고 데이터베이스 상태의 논리적 일관성을 보장하는 `트랜잭션 매니저`
                - 트랜잭션에서 접근하는 데이터베이스 객체에 대한 잠금을 제어하는 `잠금 매니저`
                - 디스크에 저장된 데이터에 대한 접근 및 저장 방식을 정의하는 `액세스 메소드`
                - 데이터 페이지를 메모리에 캐시하는 `버퍼 매니저`
                - 로그를 유지 관리하고 장애 발생 시 시스템을 복구하는 `복구 매니저`
                - 로 구성됨
- 인메모리 DBMS vs 디스크 기반 DBMS
    - 디스크 기반 DBMS는 대부분의 데이터를 디스크에 저장하고 메모리는 캐시 or 임시 저장용도로 사용
    - 인메모리 DBMS는 메모리에 데이터를 저장하고 디스크는 복구와 로그 저장용도로 사용
        - 사용 이유
            - 상대적으로 낮은 데이터 접근 비용 등의 성능
            - 세밀한 접근 단위
    - 인메모리 데이터베이스의 지속성
        - 데이터의 지속성을 보장하고 데이터 손실을 방지하기 위해 디스크에 백업함
- 칼럼형 DBMS vs 로우형 DBMS
    - 칼럼 저장 방식: 테이블을 수직 분할함 (같은 칼럼에 속하는 값들을 함께 저장함)
        - 집계 분석 작업에 적합
    - 로우 저장 방식: 테이블을 수평 분할함 (같은 로우에 속하는 값들을 함께 저장함)
        - 공간 지역성을 극대화할 수 있음
- 와이드 칼럼 스토어
    - 칼렴형 DBMS와는 다름
    - 추가로 살펴보자
- 데이터 파일
    - 디렉터리와 파일 구조에 기반한 파일 시스템을 사용하지 않고 특수한 포맷을 사용함
        
        → 왜?
        
        - 저장 효율성: 저장 오버헤드를 최소화하는 방식으로 포맷을 구성
        - 접근 효율성: 최소한의 단계로 원하는 레코드를 찾을 수 있게 함
        - 갱신 효율성: 디스크 쓰기를 최소화하는 방식으로 레코드를 갱신할 수 있음
    - 데이터 파일 종류
        - 인덱스 구조형 테이블 (Index-Organized Table, IOT)
            - 인덱스 파일과 함께 사용됨
        - 힙 구조형 테이블 (Heap-Organized Table)
            - 데이터를 순차적으로 추가
        - 해시 구조형 테이블 (Hash-Organized Table)
- 인덱스 파일
    - 인덱스 파일을 데이터 파일과 분리함
        - 인덱스 파일에는 레코드에 대한 메타데이터를 저장함
        - 이를 사용해 데이터 파일에서의 레코드 위치를 찾을 수 있게 함
    - Clustered Index
        
        : 데이터 파일 자체를 키 값에 따라 정렬
        
    - Non-Clustered Index
        
        : 데이터 파일과 별도로 인덱스 파일을 생성하여 키 값을 기준으로 데이터 레코드의 위치를 맵핑
        
- 기본 인덱스를 통한 간접 참조
    - 흠 이해안됨
- 버퍼링과 불변성, 순서화
    - 버퍼링
        
        : 데이터를 디스크에 쓰기 전, 일부를 메모리에 저장
        
        → 디스크에는 블록 단위로 저장하기 때문에, 블록을 채워서 쓰는 것이 바람직함
        
    - 불변성
        - 데이터 수정 시, 새로 저장함
    - 순서화
        - 디스크 페이지에 데이터 레코드를 키 순서로 저장함

### CH02. B-트리 개요

- 디스크 기반 스토리지용 트리
    - BST에 key (인덱스) 는 순서대로 삽입되지 않음
        
        → 데이터가 가까운 위치에 저장되지 않을 가능성이 높음 (데이터 지역성 활용 힘듦)
        
    - 또한 트리의 높이가 높아질수록 Disk I/O 가 많아짐 → 비효율
    
    ⇒ 디스크에 저장하기 위해선 (1) 가질 수 있는 노드의 수가 많고 (2) 높이가 낮아야 함!
    
- 디스크 기반 자료 구조
    - 작업의 단위는 여러 페이지들이 모인 블록임
- B-트리 계층
    - 루트 노드 / 내부 노드 / 리프 노드
    - 페이지 기반 자료구조이므로 노드와 페이지는 같은 의미로 사용됨
- 함께 읽어보면 좋은 자료 [[Link](https://seastar105.tistory.com/139)]

### CH03. 파일 포맷

- 파일 포맷의 중요성
    - 파일 포맷을 잘 최적화해야 Disk I/O 횟수를 줄일 수 있기 때문에 매우 중요함
- 바이너리 인코딩 (직렬화)
    - 디스크에 저장된 데이터는 (`malloc`, `free` 등이 아닌) `read`, `write` 함수만을 사용할 수 있음
    - 기본형 (Integer, float, …)
        - 빅 엔디언: 최상위 바이트부터 내림차순으로 저장
        - 리틀 엔디언: 최상위 바이트부터 오름차순으로 저장
        - 부동소수점을 사용함
    - 문자열과 가변 길이 데이터
        - 사이즈를 저장하고 알맞게 인코딩해서 저장
- 파일 포맷 설계 원칙
    - 물리적으로는 블록 단위로 읽고 씀
    - 논리적으로는 페이지 단위로 읽고 씀
    - 파일 = 헤더 + N * 페이지 + 트레일러
    - 페이지를 구성할 때 만약 레코드의 필드가 모두 고정 사이즈라면 차곡차곡 쌓으면 됨
    - 하지만, 가변 길이 필드가 포함된다면? 최적화가 필요함
        
        → 슬롯 페이지 (Slotted Page) 사용
        
    - 슬롯 페이지
        - 페이지는 슬롯으로 구성됨
        - 페이지 내에 각 슬롯의 시작점을 가르키는 포인터가 따로 존재함
        - 만약 슬롯(셀)을 삭제하게 되면? → 삭제하고 free block으로 처리함 → 이후 최초적합 or 최적적합 알고리즘으로 재할당함
- 체크섬
    - 페이지 헤더에 있는 체크섬을 통해 데이터 손상을 확인함
    - 데이터를 쓸 때, 체크섬을 계산해두고 저장
    - 데이터를 읽을 때, 저장해둔 체크섬을 통해 손상 여부 파악
- 함께 읽어보면 좋은 자료 [[Link](https://code-run.tistory.com/23)]

### CH04. B-트리 구현

- 페이지 헤더
    - 탐색 / 유지보수 / 최적화 에 필요한 페이지에 대한 정보를 저장
    - 플래그, 레이아웃, 셀 개수 등을 저장
    - 매직 넘버
        - 페이지의 종류, 버전, 검증, 상태 체크 등의 정보 포함
        - 고유한 숫자 or 바잍트 시퀀스
    - 형제 링크
        - 좌우에 있는 형재 페이지의 포인터를 저장하기도 함
    - 하이 키
        - 일반적인 B-트리는 key 가 N 개면 포인터는 N + 1개지만, 하이 키를 저장하는 방식에서는 키도 N + 1개를 저장함
        - 즉, 마지막 키는 마지막 포인터가 가르키는 서브트리의 가장 큰 키 값임
- 오버플로우 페이지
    - 페이지에 새로운 데이터가 삽입될 때, 크기를 초과한다면 같은 단위의 페이지를 만들고 원본 페이지에 연결함 = 오버플로우 페이지
    - 대부분의 B-트리는 고정 크기의 바이트만 노드에 저장하고 나머지는 오버플로우 페이지에 저장함
- 탐색 경로
    - 트리의 구조가 변경될 때, 루트에서 리프 노드 or 삽입 지점까지 트리를 순회해야하는데, 도착 전까지는 분할 or 병합의 발생 여부를 알 수 없음
        
        → 탐색 경로를 저장
        
    - 저장한 탐색 경로를 기반으로 분할 or 병합을 전파시킴
- 리밸런싱
    - 분할/병합 전 같은 레벨에서 빈 공간이 많은 노드로 원소를 이동시키거나
    - 노드의 삽입/삭제 시 리밸런싱이 수행됨
    
    → 목적은 탐색 시간을 줄이게 하기 위함 (트리의 높이가 높아지는 것을 방지)
    
- 오른쪽 추가 기법
    - 기본 인덱스 키를 자동 증가 값으로 사용하는 경우
        
        → 모든 삽입이 인덱스의 끝 (가장 오른쪽 리프) 에서만 발생
        
    - 벌크 로딩 시에도 오른쪽에만 계속 추가할 수 있는 이점을 누릴 수 있음
        - 또는 페이지 단위로 저장시켜버려도 됨
- 페이지 단편화
    - 페이지 내에 단편화가 심해지면 가비지 컬렉션이 수행되는 컴팩션이 발생
    - 데이터를 삭제하게 되면, 보통은 셀 오프셋만 제거하고 데이터 셀은 남겨두는데 컴팩션 과정에서 이러한 데드 셀들을 회수함

## CH05. 트랜잭션 처리와 복구

- 트랜잭션은 트랜잭션 매니저에 의해 관리됨
    - 트랜잭션의 세부 단계를 제어 / 관리 / 스케줄
- 락 매니저 (Lock Manager)
    - 리소스에 대한 동시 접근을 제어하고 데이터 무결성을 보장함
    - Lock이 요청되면 Lock Manager는 다른 트랜잭션이 공유 or 배타적 Lock으로 해당 리소스를 이미 소유하고 있는지 확인함
    - 배타적 Lock이라면 하나의 트랜잭션만 리소스를 소유할 수 있도록 제어함
- 페이지 캐시 (Page Cache)
    - 영구 저장소 (Disk) 와 스토리지 엔진 사이에서 중재자 역할을 함
    - 메인 메모리의 변경 사항을 저장 + Disk와 동기화되지 않은 페이지를 캐시함
    - 데이터베이스에 대한 모든 상태 변경 사항은 우선 페이지 캐시에 저장됨
- 로그 매니저 (Log Manager)
    - Disk와 동기화되지 않은 페이지 캐시의 내용이 손실되지 않도록 History 를 저장함
    - 부팅 시 작업을 재수행 / 중단된 트랜잭션에 의한 복원 등에 로그를 활용
- 버퍼 관리
    - Disk 접근 횟수를 줄이기 위해 페이지를 메모리에 캐시 → 페이지 캐시
    - 페이지가 수정되지 않았다면 페이지 캐시에서 읽음
- 캐싱
    - 페이지에 대한 변경 사항은 Disk에 쓰기 전까지 메모리에 남아있음
    - 모든 프로세스는 직접적으로 Disk에 쓸 수 없음
        
        메모리 → Disk 의 플러시는 단방향
        
    - 페이지 캐시에 대상 데이터가 없다면, Disk 에서 메모리로 가져오고 (캐싱) 반환함
        
        (+ 참조 상태로 표시함)
        
    - 페이지가 수정되면 더티 플래그를 통해 동기화가 필요함을 표시함
- 캐시 만료
    - 페이지 캐시의 크기는 Disk에 비해 훨씬 작음 → 부족한 경우 만료시켜야함
    - 페이지가 이미 동기화되어있거나 (플러시됐거나 수정되지 않은 상태) 참조 or 고정 상태가 아니라면 만료 대상임
    - 더티 페이지는 만료시키기 전 플러시해줘야함
- 체크포인트 프로세스
    - 체크포인트 프로세스는 플러시 시점을 제어함
    - WAL (Write Ahead Log) 와 페이지 캐시의 싱크가 맞도록 조정함
    - 플러시가 완료된 페이지와 관련한 로그만 WAL 에서 삭제될 수 있음
    - 즉, 요녀석을 통해 장애 발생 시 플러시되지 않은 페이지 정보를 다시 메모리에 올릴 수 있음
- 페이지 고정
    - 가까운 시간 내에 다시 요청될 확률이 높은 페이지는 페이키 캐시에 고정해둘 수 있음
    - 예를 들어, B 트리의 상위 레벨 노드는 읽기를 위한 접근 횟수가 높으므로 페이지 고정시켜둘 수 있음
- 페이지 교체 알고리즘
    - OS의 페이지 교체 알고리즘과 큰 차이 없음
- 복구
    - WAL를 적극 활용함
    - 디스크에 저장된 페이지에 대한 변경 사항을 페이지 캐시에 버퍼링하는 동시에 데이터베이스 시스템 맥락에서 지속성을 보장함
    - 캐시된 페이지가 디스크와 동기화될 때까지 작업 이력을 디스크에 저장함
        
        → 모든 작업을 실제 페이지에 적용하기 전 디스크에 로깅함
        
    - 장애 발생 시 로그를 기반으로 마지막 메모리 상태를 재구성함
- 로그의 시맨틱
    - WAL은 한번 쓰면 불변함 → 순차적으로 쓸 수 있음
    - WAL에는 단조 증가하는 고유 로그 시퀀스 번호 (LSN)이 있음
    - 변경 이력만 있는 것은 아님
    - 트랜잭션 완료 여부를 나타내는 로그도 있음
        
        이 로그가 프러시되기 전까지는 해당 트랜잭션은 커밋된 것으로 간주할 수 없음
        → 체크포인트에 도달했다고 표현함

- 하지만 체크포인트 작업이 완료될 때까지 다른 작업을 모두 중지하는 것은 비효율적임
    
    → 퍼지 체크포인트를 사용함 (vpdlwlemfdl qlehdrlwjrdmfh vmffjtlehla)
    
- 스틸 & 포스 정책
    - 스틸
        - 트랜잭션이 수정한 페이지를 커밋하기도 전에 플러시하는 것을 허용
        - 노스틸은 허용하지 않음
        - 노스틸 정책에서는 디스크에는 이전 상태 / 로그에는 최신 변경 상태가 저장되어있으므로 리두 로그만을 사용하여 상태를 복구할 수 있음
    - 포스
        - 트랜잭션이 수정한 모든 페이지를 커밋 전에 플러시함
        - 노포스는 일부 페이지가 디스크로 플러시되지 않았어도 트랜잭션 커밋을 허용함
        - 포스 정책에서는 트랜잭션은 커밋 전 플러시되기 때문에, 장애 복구 시 커밋 결과를 다시 쓰지 않아도 됨
- 동시성 제어
    - 트랜잭션 매니저와 락 매니저가 제어
    - 낙관적 동시성 제어 (Optimistic)
        - 여러 트랜잭션이 동시에 읽고 쓰는 것을 허용함
        - 커밋 전 충돌이 발생할 경우 트랜잭션을 중단시킴
    - 다중 버전 동시성 제어 (MVCC)
        - 여러 버전의 레코드를 저장해 트랜잭션이 시작된 시점의 스냅샷을 사용함
    - 비관적 동시성 제어 (Pessimistic)
        - 락 기반 방식 → 먼저 접근한 트랜잭션이 해당 레코드에 대한 락을 획득
        - 무잠금 방식 → 완료되지 않은 트랜잭션의 스케줄에 따른 다른 트랜잭션의 수행을 제한함
    - 직렬화 가능성
        - 트랜잭션을 스케줄할 때 가장 안전한 것은 직렬 스케줄로 만드는 것 (일렬로)
        - 하지만 성능이 좋지 못함
        - ACID 속성과 트랜잭션 결과의 정확성이 보장될 경우, 일부 작업을 병렬로 수행시킴
    - 읽기 이상 현상
        - Dirty Read: 아직 커밋되지 않은 다른 트랜잭션의 결과를 읽음
        - Non-repeatable Read: 한 트랜잭션 내에서 같은 쿼리가 다른 결과를 읽음
        - Phantom Read: 한 트랜잭션 내에서 범위 커리 (여러 row) 가 다른 결과를 읽음
    - 쓰기 이상 현상
        - Lost Update: 쓰기에 락이 걸리지 않은 경우 두 커밋 중 하나의 커밋 사항만 반영됨
        - Dirty Write: 트랜잭션이 커밋되지 않은 값을 읽고 수정 or 커밋하는 현상
        - Write Skew
    - 격리 수준
        - Read Uncommited: 그냥 다 읽음
        - Read Commited: 커밋된 트랜잭션의 데이터만 읽음 (Dirty Read 만 방지)
        - Repeatable Read: 트랜잭션ID에 따라 스냅샷을 읽음 (Non-repeatable Read까지 방지)
        - Serializable: 무조건 직렬화해서 수행
- 락 (Lock)
- 래치 (Latch)
    - 물리적 무결성을 보장하기 위해 사용
    - 물리적 트리 구조를 보호함
    - 특정 페이지에 동시에 접근하기 위해서는 래치를 획득해야 함
    - RW Lock
        - 동시에 같은 페이지에 접근하는 것은 허용
        - 하지만 Writer는 페이지를 독점해야 함
    - Latch Crabbing
        - 래치를 루트에서 리프노드사이의 모든 래치를 획득하도록 하는 경우, 병목현상을 방지할 수 있는 방법
        - 래치를 최대한 짧게 소유하고, 래치가 필요하지 않게된 순간 바로 해제