> 이 책을 읽는 이유: 
> 
> 백엔드 개발자는 결국 데이터베이스에 데이터를 생성하고 가져오고 가공한다. 
> 
> 데이터베이스가 어떻게 작동하는지를 알면 더 효율적인 로직을 짤 수 있지 않을까?
> 

## 1부. 스토리지 엔진

스토리지 엔진은

- DBMS에서 데이터를 메모리와 디스크에 저장하고
- 검색 및 관리하며
- 각 노드에 데이터를 영구 저장함
- 그리고 복잡한 쿼리를 수행할 수 있도록 데이터를 세밀하게 조작할 수 있는 간단한 API를 제공함

### CH01. 소개 및 개요

- DBMS 구조
    - 표준화된 구조는 존재하지는 않음
    - 일반적으로는
        - `클라이언트의 요청`은 `트랜스포트 서브시스템`을 통해 전달됨
            
            (요청은 쿼리 형태)
            
        - `트랜스포트 서브시스템`은 쿼리를 `쿼리 프로세서`에게 전달함
            - `쿼리 프로세서`는 쿼리를 해석 / 분석 / 검증 함
            - 분석된 쿼리는 `쿼리 옵티마이저`에게 전달됨
            - `쿼리 옵티마이저`는 가장 효율적인 쿼리 실행 계획을 생성함
        - (로컬인 경우), `스토리지 엔진`이 쿼리를 수행함
            - 스토리지 엔진은
                - 트랜잭션을 스케줄링하고 데이터베이스 상태의 논리적 일관성을 보장하는 `트랜잭션 매니저`
                - 트랜잭션에서 접근하는 데이터베이스 객체에 대한 잠금을 제어하는 `잠금 매니저`
                - 디스크에 저장된 데이터에 대한 접근 및 저장 방식을 정의하는 `액세스 메소드`
                - 데이터 페이지를 메모리에 캐시하는 `버퍼 매니저`
                - 로그를 유지 관리하고 장애 발생 시 시스템을 복구하는 `복구 매니저`
                - 로 구성됨
- 인메모리 DBMS vs 디스크 기반 DBMS
    - 디스크 기반 DBMS는 대부분의 데이터를 디스크에 저장하고 메모리는 캐시 or 임시 저장용도로 사용
    - 인메모리 DBMS는 메모리에 데이터를 저장하고 디스크는 복구와 로그 저장용도로 사용
        - 사용 이유
            - 상대적으로 낮은 데이터 접근 비용 등의 성능
            - 세밀한 접근 단위
    - 인메모리 데이터베이스의 지속성
        - 데이터의 지속성을 보장하고 데이터 손실을 방지하기 위해 디스크에 백업함
- 칼럼형 DBMS vs 로우형 DBMS
    - 칼럼 저장 방식: 테이블을 수직 분할함 (같은 칼럼에 속하는 값들을 함께 저장함)
        - 집계 분석 작업에 적합
    - 로우 저장 방식: 테이블을 수평 분할함 (같은 로우에 속하는 값들을 함께 저장함)
        - 공간 지역성을 극대화할 수 있음
- 와이드 칼럼 스토어
    - 칼렴형 DBMS와는 다름
    - 추가로 살펴보자
- 데이터 파일
    - 디렉터리와 파일 구조에 기반한 파일 시스템을 사용하지 않고 특수한 포맷을 사용함
        
        → 왜?
        
        - 저장 효율성: 저장 오버헤드를 최소화하는 방식으로 포맷을 구성
        - 접근 효율성: 최소한의 단계로 원하는 레코드를 찾을 수 있게 함
        - 갱신 효율성: 디스크 쓰기를 최소화하는 방식으로 레코드를 갱신할 수 있음
    - 데이터 파일 종류
        - 인덱스 구조형 테이블 (Index-Organized Table, IOT)
            - 인덱스 파일과 함께 사용됨
        - 힙 구조형 테이블 (Heap-Organized Table)
            - 데이터를 순차적으로 추가
        - 해시 구조형 테이블 (Hash-Organized Table)
- 인덱스 파일
    - 인덱스 파일을 데이터 파일과 분리함
        - 인덱스 파일에는 레코드에 대한 메타데이터를 저장함
        - 이를 사용해 데이터 파일에서의 레코드 위치를 찾을 수 있게 함
    - Clustered Index
        
        : 데이터 파일 자체를 키 값에 따라 정렬
        
    - Non-Clustered Index
        
        : 데이터 파일과 별도로 인덱스 파일을 생성하여 키 값을 기준으로 데이터 레코드의 위치를 맵핑
        
- 기본 인덱스를 통한 간접 참조
    - 흠 이해안됨
- 버퍼링과 불변성, 순서화
    - 버퍼링
        
        : 데이터를 디스크에 쓰기 전, 일부를 메모리에 저장
        
        → 디스크에는 블록 단위로 저장하기 때문에, 블록을 채워서 쓰는 것이 바람직함
        
    - 불변성
        - 데이터 수정 시, 새로 저장함
    - 순서화
        - 디스크 페이지에 데이터 레코드를 키 순서로 저장함

### CH02. B-트리 개요

- 디스크 기반 스토리지용 트리
    - BST에 key (인덱스) 는 순서대로 삽입되지 않음
        
        → 데이터가 가까운 위치에 저장되지 않을 가능성이 높음 (데이터 지역성 활용 힘듦)
        
    - 또한 트리의 높이가 높아질수록 Disk I/O 가 많아짐 → 비효율
    
    ⇒ 디스크에 저장하기 위해선 (1) 가질 수 있는 노드의 수가 많고 (2) 높이가 낮아야 함!
    
- 디스크 기반 자료 구조
    - 작업의 단위는 여러 페이지들이 모인 블록임
- B-트리 계층
    - 루트 노드 / 내부 노드 / 리프 노드
    - 페이지 기반 자료구조이므로 노드와 페이지는 같은 의미로 사용됨
- 함께 읽어보면 좋은 자료 [[Link](https://seastar105.tistory.com/139)]