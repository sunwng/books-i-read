> 이 책을 읽는 이유: 
> 
> 백엔드 개발자는 결국 데이터베이스에 데이터를 생성하고 가져오고 가공한다. 
> 
> 데이터베이스가 어떻게 작동하는지를 알면 더 효율적인 로직을 짤 수 있지 않을까?
> 

## 1부. 스토리지 엔진

스토리지 엔진은

- DBMS에서 데이터를 메모리와 디스크에 저장하고
- 검색 및 관리하며
- 각 노드에 데이터를 영구 저장함
- 그리고 복잡한 쿼리를 수행할 수 있도록 데이터를 세밀하게 조작할 수 있는 간단한 API를 제공함

### CH01. 소개 및 개요

- DBMS 구조
    - 표준화된 구조는 존재하지는 않음
    - 일반적으로는
        - `클라이언트의 요청`은 `트랜스포트 서브시스템`을 통해 전달됨
            
            (요청은 쿼리 형태)
            
        - `트랜스포트 서브시스템`은 쿼리를 `쿼리 프로세서`에게 전달함
            - `쿼리 프로세서`는 쿼리를 해석 / 분석 / 검증 함
            - 분석된 쿼리는 `쿼리 옵티마이저`에게 전달됨
            - `쿼리 옵티마이저`는 가장 효율적인 쿼리 실행 계획을 생성함
        - (로컬인 경우), `스토리지 엔진`이 쿼리를 수행함
            - 스토리지 엔진은
                - 트랜잭션을 스케줄링하고 데이터베이스 상태의 논리적 일관성을 보장하는 `트랜잭션 매니저`
                - 트랜잭션에서 접근하는 데이터베이스 객체에 대한 잠금을 제어하는 `잠금 매니저`
                - 디스크에 저장된 데이터에 대한 접근 및 저장 방식을 정의하는 `액세스 메소드`
                - 데이터 페이지를 메모리에 캐시하는 `버퍼 매니저`
                - 로그를 유지 관리하고 장애 발생 시 시스템을 복구하는 `복구 매니저`
                - 로 구성됨
- 인메모리 DBMS vs 디스크 기반 DBMS
    - 디스크 기반 DBMS는 대부분의 데이터를 디스크에 저장하고 메모리는 캐시 or 임시 저장용도로 사용
    - 인메모리 DBMS는 메모리에 데이터를 저장하고 디스크는 복구와 로그 저장용도로 사용
        - 사용 이유
            - 상대적으로 낮은 데이터 접근 비용 등의 성능
            - 세밀한 접근 단위
    - 인메모리 데이터베이스의 지속성
        - 데이터의 지속성을 보장하고 데이터 손실을 방지하기 위해 디스크에 백업함
- 칼럼형 DBMS vs 로우형 DBMS
    - 칼럼 저장 방식: 테이블을 수직 분할함 (같은 칼럼에 속하는 값들을 함께 저장함)
        - 집계 분석 작업에 적합
    - 로우 저장 방식: 테이블을 수평 분할함 (같은 로우에 속하는 값들을 함께 저장함)
        - 공간 지역성을 극대화할 수 있음
- 와이드 칼럼 스토어
    - 칼렴형 DBMS와는 다름
    - 추가로 살펴보자
- 데이터 파일
    - 디렉터리와 파일 구조에 기반한 파일 시스템을 사용하지 않고 특수한 포맷을 사용함
        
        → 왜?
        
        - 저장 효율성: 저장 오버헤드를 최소화하는 방식으로 포맷을 구성
        - 접근 효율성: 최소한의 단계로 원하는 레코드를 찾을 수 있게 함
        - 갱신 효율성: 디스크 쓰기를 최소화하는 방식으로 레코드를 갱신할 수 있음
    - 데이터 파일 종류
        - 인덱스 구조형 테이블 (Index-Organized Table, IOT)
            - 인덱스 파일과 함께 사용됨
        - 힙 구조형 테이블 (Heap-Organized Table)
            - 데이터를 순차적으로 추가
        - 해시 구조형 테이블 (Hash-Organized Table)
- 인덱스 파일
    - 인덱스 파일을 데이터 파일과 분리함
        - 인덱스 파일에는 레코드에 대한 메타데이터를 저장함
        - 이를 사용해 데이터 파일에서의 레코드 위치를 찾을 수 있게 함
    - Clustered Index
        
        : 데이터 파일 자체를 키 값에 따라 정렬
        
    - Non-Clustered Index
        
        : 데이터 파일과 별도로 인덱스 파일을 생성하여 키 값을 기준으로 데이터 레코드의 위치를 맵핑
        
- 기본 인덱스를 통한 간접 참조
    - 흠 이해안됨
- 버퍼링과 불변성, 순서화
    - 버퍼링
        
        : 데이터를 디스크에 쓰기 전, 일부를 메모리에 저장
        
        → 디스크에는 블록 단위로 저장하기 때문에, 블록을 채워서 쓰는 것이 바람직함
        
    - 불변성
        - 데이터 수정 시, 새로 저장함
    - 순서화
        - 디스크 페이지에 데이터 레코드를 키 순서로 저장함

### CH02. B-트리 개요

- 디스크 기반 스토리지용 트리
    - BST에 key (인덱스) 는 순서대로 삽입되지 않음
        
        → 데이터가 가까운 위치에 저장되지 않을 가능성이 높음 (데이터 지역성 활용 힘듦)
        
    - 또한 트리의 높이가 높아질수록 Disk I/O 가 많아짐 → 비효율
    
    ⇒ 디스크에 저장하기 위해선 (1) 가질 수 있는 노드의 수가 많고 (2) 높이가 낮아야 함!
    
- 디스크 기반 자료 구조
    - 작업의 단위는 여러 페이지들이 모인 블록임
- B-트리 계층
    - 루트 노드 / 내부 노드 / 리프 노드
    - 페이지 기반 자료구조이므로 노드와 페이지는 같은 의미로 사용됨
- 함께 읽어보면 좋은 자료 [[Link](https://seastar105.tistory.com/139)]

### CH03. 파일 포맷

- 파일 포맷의 중요성
    - 파일 포맷을 잘 최적화해야 Disk I/O 횟수를 줄일 수 있기 때문에 매우 중요함
- 바이너리 인코딩 (직렬화)
    - 디스크에 저장된 데이터는 (`malloc`, `free` 등이 아닌) `read`, `write` 함수만을 사용할 수 있음
    - 기본형 (Integer, float, …)
        - 빅 엔디언: 최상위 바이트부터 내림차순으로 저장
        - 리틀 엔디언: 최상위 바이트부터 오름차순으로 저장
        - 부동소수점을 사용함
    - 문자열과 가변 길이 데이터
        - 사이즈를 저장하고 알맞게 인코딩해서 저장
- 파일 포맷 설계 원칙
    - 물리적으로는 블록 단위로 읽고 씀
    - 논리적으로는 페이지 단위로 읽고 씀
    - 파일 = 헤더 + N * 페이지 + 트레일러
    - 페이지를 구성할 때 만약 레코드의 필드가 모두 고정 사이즈라면 차곡차곡 쌓으면 됨
    - 하지만, 가변 길이 필드가 포함된다면? 최적화가 필요함
        
        → 슬롯 페이지 (Slotted Page) 사용
        
    - 슬롯 페이지
        - 페이지는 슬롯으로 구성됨
        - 페이지 내에 각 슬롯의 시작점을 가르키는 포인터가 따로 존재함
        - 만약 슬롯(셀)을 삭제하게 되면? → 삭제하고 free block으로 처리함 → 이후 최초적합 or 최적적합 알고리즘으로 재할당함
- 체크섬
    - 페이지 헤더에 있는 체크섬을 통해 데이터 손상을 확인함
    - 데이터를 쓸 때, 체크섬을 계산해두고 저장
    - 데이터를 읽을 때, 저장해둔 체크섬을 통해 손상 여부 파악
- 함께 읽어보면 좋은 자료 [[Link](https://code-run.tistory.com/23)]

### CH04. B-트리 구현

- 페이지 헤더
    - 탐색 / 유지보수 / 최적화 에 필요한 페이지에 대한 정보를 저장
    - 플래그, 레이아웃, 셀 개수 등을 저장
    - 매직 넘버
        - 페이지의 종류, 버전, 검증, 상태 체크 등의 정보 포함
        - 고유한 숫자 or 바잍트 시퀀스
    - 형제 링크
        - 좌우에 있는 형재 페이지의 포인터를 저장하기도 함
    - 하이 키
        - 일반적인 B-트리는 key 가 N 개면 포인터는 N + 1개지만, 하이 키를 저장하는 방식에서는 키도 N + 1개를 저장함
        - 즉, 마지막 키는 마지막 포인터가 가르키는 서브트리의 가장 큰 키 값임
- 오버플로우 페이지
    - 페이지에 새로운 데이터가 삽입될 때, 크기를 초과한다면 같은 단위의 페이지를 만들고 원본 페이지에 연결함 = 오버플로우 페이지
    - 대부분의 B-트리는 고정 크기의 바이트만 노드에 저장하고 나머지는 오버플로우 페이지에 저장함
- 탐색 경로
    - 트리의 구조가 변경될 때, 루트에서 리프 노드 or 삽입 지점까지 트리를 순회해야하는데, 도착 전까지는 분할 or 병합의 발생 여부를 알 수 없음
        
        → 탐색 경로를 저장
        
    - 저장한 탐색 경로를 기반으로 분할 or 병합을 전파시킴
- 리밸런싱
    - 분할/병합 전 같은 레벨에서 빈 공간이 많은 노드로 원소를 이동시키거나
    - 노드의 삽입/삭제 시 리밸런싱이 수행됨
    
    → 목적은 탐색 시간을 줄이게 하기 위함 (트리의 높이가 높아지는 것을 방지)
    
- 오른쪽 추가 기법
    - 기본 인덱스 키를 자동 증가 값으로 사용하는 경우
        
        → 모든 삽입이 인덱스의 끝 (가장 오른쪽 리프) 에서만 발생
        
    - 벌크 로딩 시에도 오른쪽에만 계속 추가할 수 있는 이점을 누릴 수 있음
        - 또는 페이지 단위로 저장시켜버려도 됨
- 페이지 단편화
    - 페이지 내에 단편화가 심해지면 가비지 컬렉션이 수행되는 컴팩션이 발생
    - 데이터를 삭제하게 되면, 보통은 셀 오프셋만 제거하고 데이터 셀은 남겨두는데 컴팩션 과정에서 이러한 데드 셀들을 회수함