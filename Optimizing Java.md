> 이 책을 읽는 이유: ‘모던 자바 인 액션’으로 스트림 API, 함수형 API, Optional 등 자바의 현대 문법에 대해 공부하였는데, 이제는 자바와 JVM 내부를 뜯어보고 성능을 들여다보자고 결심함
> 

### CH01. 성능과 최적화

- 자바 성능 개요
    - ‘자바는 블루 칼라 언어다. 박사 학위 논문 주제가 아니라 일을 위한 언어다.’
    - 그렇기에 많은 부분에서 실용적인 측면이 존재함
    - 그것의 대표적인 예는 GC
- 성능 분류
    - 처리율: 일정 시간동안 완료한 작업 단위 수 (e.g. TPS)
    - 지연: 하나의 작업이 처리될 때까지 걸리는 시간
    - 용량: 시스템이 동시에 처리 가능한 작업 단위의 수
        - 보통 특정 처리율 or 지연 값을 전제로 가능한 처리량으로 표시
    - 사용률: 리소스 사용률
    - 효율: 처리율 / 리소스 사용률
    - 확장성: 리소스 추가에 따른 처리율 변화
    - 저하: 부하가 증가했을 때 지연 or 처리율의 변화

### CH02. JVM 이야기

- 인터프리팅과 클래스로딩
    - JVM은 스택 기반의 해석 머신임
    - 일부 결과를 실행 스택에 보관하고, 이 스택의 peek 값을 가져와 계산 (여기서 스택이 평가 스택임)
    - 그리고 평가 스택은 메소드별로 하나씩 생성됨
    - JVM 은 클래스를 동적 로딩함, 즉 런타임 시에 그때 그때 필요한 클래스를 메모리에 올린다는 것
    - 자바 어플리케이션을 실행하면,
    - 먼저 가상 머신 프로세스 (자바 바이너리)를 실행시킴
    - 그리고 스택 머신이 초기화됨
    - 먼저, 부트스트랩 클래스 로더가 켜짐
        - 그리고 가장 상위 클래스 로더임
    - 부트스트랩 클래스 로더가 자바 런타임 코어 클래스를 로드함
        
        (자바 런타임 코어 클래스는 최소한의 필수 클래스들임)
        
    - 이후, 확장 클래스로더가 켜짐 (확장 자바 클래스들을 로드하는 역할)
    - 그 다음, 어플리케이션 클래스 로더가 켜지면서 내가 실행시킨 클래스를 로드함
    - 만약 실행 중, 처음 보는 클래스가 있다면 디펜던시에 로드하고,
    찾지 못하면 확장 클래스로더 → 부트스트랩 클래스로더 순으로 룩업을 요청함
    - 그런데도 못찾았을 때 나는 것이 바로 `ClassNotFoundException`
- 바이트코드 실행
    - 자바 컴파일러가 `javac`를 이용하여 `.java` 인 자바 소소 코드를 `.class` 인 바이트코드로 변환
        - 스칼라로 작성한 코드는 scalac를 이용하여 바이트코드로 변환한다고 함
    - OS 에 무관하게 표현된 바이트코드를 순차적으로 읽음
- 핫스팟 JVM
    - : 진화된 JVM (가장 일반적인 현대의 JVM)
    - JIT 컴파일러를 사용함
        - 여기서 먼저, JIT 컴파일과 AOT 컴파일을 알고 넘어가보자
            - JIT: Just in Time, 그때 그때 컴파일함
            - AOT: Ahead of Time, 미리 컴파일함
        - 여기서 의문점이 생길 수 밖에 없음
            - 내가 기존에 알던 지식은,
                - 자바컴파일러에 의해 소스코드는 바이트코드로 컴파일되고
                - 자바 인터프리터에 의해 한줄 한줄 실행됨
                - 즉, 컴파일러와 인터프리터 두가지 모두 존재하는 구조임
            - 그렇다면 어떻게 JIT 컴파일러가 사용된다는 것일까?
                - 바이트코드는 모두 미리 컴파일되어야하는 AOT 방식만 가능할텐데…
            - 바이트코드로의 컴파일은 기존의 자바컴파일러가 똑같이 작업함
            - 그 이후, 인터프리팅 과정에서 인터프리팅 성능이 낮은 것을 개선하기 위해 사용되는 것이 JIT 컴파일러였음
            - 바이트코드를 읽는 과정에서는 아무리 JVM이 가상화되어있다고 하지만, 결국 환경에 맞는 기계어로 실행시켜야하는데 인터프리팅 과정이 느렸던 것이고
            - JIT 컴파일러가 이 시점에서 자주 사용되는 코드 파트들을 미리 기계어로 컴파일 해둠
        - JIT 컴파일의 대상은 주로
            - 자주 실행되는 코드
            - 그리고 값이 자주 변하지 않는 코드
- JVM 메모리 관리
    - 기존의 언어들 (자바가 나오기 전)은 메모리 관리를 직접 해줘야했지만, 너무 힘들게 했음
    - 그래서 그 유명하고 좋은 GC가 적용되었음
    - GC는 힙을 자동관리 해줌
- JMM (Java Memory Model)
    - 멀티스레드를 지원하게 되며 JVM은 메모리 관리를 더욱 빡세게 해야했음
- JVM 모니터링, 툴링
    - Java Management Extensions
    - Java Agent
    - JVM Tool Interface
    - Serviceability Agent